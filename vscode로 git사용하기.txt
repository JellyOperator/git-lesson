왜 git을 사용해야 할까요?
코드를 짜다가 실수해서 2일 전으로 돌아가고 싶거나
코드를 짠 과거 타임라인 등을 보기 위해서는
1. 매일매일 손수 파일 복사본을 만들어두거나
2. git과 같은 형상관리 프로그램을 사용하는 방법이 있습니다. 


(시작)
폴더를 우클릭해서 파워셀을 엽니다.
git --global user.email "설정할 이메일" //폴더의 이메일을 설정해 줍시다.
git --global user.name "내 이름" //마찬가지로 이름을 설정해 줍시다.

을 통해 기본 설정을 마칩니다;


(연습)
이제는 폴더를 우클릭 해서 vsCode를 열어봅시다.

코드가 맘에 들어서 따로 기록을 해두고 싶다고 생각해 봅시다.
그럼 git에 "이 파일의 현재 상태를 기록해줘~" 라고 해야 하겠죠?


(주로 쓰는 과정)
[작업 폴더 (>> git add >>) Staging Area (>> git commit >>) 저장소 Repository]

pull // git에 저장된 내용을 가져옵니다.


(바로 해봅시다!!)
git add 파일명 //수정된 파일을 추가합니다.
git commit -m '메세지' //해당 add에 메모를 추가해봅시다. (어떤 내용인지, 무슨 연유로 add를 하였는지)

형상관리를 통해 우리는 조선의 사관을 직간접적으로 체험해 보는겁니다!
앞으로의 우리가 만들어낼 역사가 git을 통해 기록되겠군요.

(사실 "기록"보다는 "버전생성"이라고 부르는 경우가 더 많아요!)



※다른 명령어들
git add 파일명1 파일명2 //여러 파일을 동시에 스테이징

git add . //모든 파일을 스테이징 (작업 폴더 내)

git status //지금 변경된 파일, 스테이징된 파일 등을 알려줍니다.

git restore (--staged 파일명) //스테이징된 파일을 취소합니다. (.을 찍으면 어떻게 될까요? )

git log (--all --onelinie --graph) //커밋 기록을 파악합니다. (그래프는 그래프로 그려줍니다.)
                                    //단 입력 후에 VIM이 켜져서 j,k로 위아래 스크롤이 가능하고
                                    //q 키로 종료합니다.

git diff //최근 commit과 현재파일의 차이점을 보여줍니다. (Vim이 켜집니다.)

git difftool //위와 같은 기능이지만 시각적으로 향상된 상태로 보여줍니다 (Vim이 켜집니다.)

git difftool ??커밋아이디?? //현재파일과 특정 커밋을 비교가능합니다.    
                ㄴ git log에서 나오는 ea46f1b와 같은 노란색 글씨

git difftool 커밋아이디1 커밋아이디2 //설명 생략


---
git config --global diff.tool vsCode
git config --gloabal difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE
//difftool을 사용할 때 VIM에디터를 vs에디터로 보여줍니다.

[근데 이런거 필요없이]
EXTENSION 툴에 Git Graph같은거 설치하면 gitdiff 대신 사용가능 (보여주는 용도이기 때문)
이럼 굳이 difftool 사용 안해도 됨


(2일차)
git branch 브랜치명 //브랜치 생성해줌 
git switch 브랜치명 //브랜치로 이동 //main 아님 master를 사용하면 처음 자리로 돌아감
git merge 브랜치명 //현재 브랜치에서 '브랜치명'을 병합합니다.

git branch -d 브랜치명 //merge 완료된 브랜치를 삭제합시다.
git branch -D 브랜치명 //merge 안한 브랜치를 삭제합니다.


git rebase & merge를 사용하는 이유는 3-way merge는 log를 확인할 때 복잡해 보입니다.
때문에 git rebase를 한 후 merge를 하여 
fast-forward merge를 진행하면 후에 보기 좋아집니다.
(단점은 conflict가 많이 날 수 있습니다.)

git rebase 중심브랜치명 //새로운브랜치로 이동 후 사용하세요
git merge 새로운브랜치명 //중심브랜치로 이동 후 사용하세요


(squash and merge) //제일 깔끔한 방법
git merge --squash 새브런치 //main 브랜치에 새로운 commit을 만든 후 merge합니다 


(3일차 복구에 대하여)
git restore 파일명 //최근 커밋된 상태로, 현재파일의 수정내용을 되돌립니다.
git restore --source 커밋아이디 파일명
//파일이 커밋아이디 시점으로 복구됩니다.

git restore --staged 파일명 //파일의 스테이징을 취소합니다.


git revert 커밋아이디 //커밋아이디에서 일어난 일을 취소해줍니다.
git revert 커밋아이디1 커밋아이디2 ~~
//여러개 동시 취소

git revert HEAD //최근 커밋된 1개만 취소됩니다.
(merge 명령으로 인해 새로 만들어진 커밋도 취소가능합니다. == merge 취소)


git reset --hard 커밋아이디 //커밋이 생성된 시점으로 되돌아갑니다. 
//이후에 추가했던 사항 또한 같이 사라집니다.

git reset --soft 커밋아이디 //스테이징은 된 상태로 돌아갑니다.
//commit을 다시 진행 가능 (메세지 변경 or 커밋 안함)

git reset --mixed 커밋아이디 //Add도 안된 상태로 돌아갑니다.
//add, commit 다시 진행 가능


------------------------------(Github에 만든 원격-온라인 저장소 사용)_
github.com은 이제 기본 브랜치 이름을 master가 아니라 main으로 사용하라고 강요합니다.

그래서 우리 로컬 작업폴더에 있는 기본 브랜치 이름도 main으로 변경해줍니다.
git branch -M main //기본 브랜치 이름 변경

git push -u 원격저장소 현재브랜치명 //로컬저장소 -> 원격저장소
//-u 옵션은 방금 입력한 주소를 기억해두라는 뜻입니다.
//한 번 사용하면 다음부터는 git push만 입력해도 됩니다.


(원격_저장소 주소 길게 입력하는게 귀찮으면)
git remote add 변수명 저장소주소 
//주소가 필요할 때마다 origin이라는 변수명을 사용가능

ex) git remote add origin https://github.com/JellyOperator/git-lesson.git
이렇게 적어놓으면, 다음번엔
git push origin main으로 짧게 사용가능

+추가로
git push -u origin main을 사용했다면 //-u 기억하기

담번엔 
git push만 해도 된다.

//이렇게 지정한 변수 목록 보기 => git remote -v


(원격_저장소 있던거 그대로 내려받기)
git clone https://원격_저장소 주소


-------------저장소에 올리기 싫은 파일은 .gitignore를 이용-------------


(타인과 협업!)

git clone 원격저장소_주소 //원격_저장소에 있던 파일들을 가져옵니다.

----------------------------
팀원이 git push를 하려면 github/acess 세팅에서
Collaborators에 팀원 깃헙아이디를 등록해놔야
git push를 사용가능하다.
----------------------------

(단, 원격 != 로컬 내용 이면 에러남 - 예방차원의 rejected)
==원격저장소에 새로운게 생겼다면 git push 못 함.

에러가 낫다면 원격저장소에 있던 모든 브런치 내용을 가져와서 
로컬저장소에 합치라는 뜻입니다.

git pull (원격저장소_주소) (원격_브랜치명) //원격저장소 -> 로컬저장소
==> git push 할 때 -u를 잘 써놨다면
git pull만 해도 작동된다.

git pull 할 때 브랜치 명시 가능
git pull origin 브랜치명 //특정 브랜치만 가져오기 가능, 
//origin은 원격_저장소 주소명을 저장한 변수


git pull 명령어는 git fetch + git merge 축약어임 
(때문에 merge conflict도 발생 가능)

fetch는 원격 저장소에 있는 커밋 중에 로컬에 없는 신규 커밋을 가져오라는 뜻
merge는 그걸 merge하라는 뜻
합쳐서 git pull로 쓸 수 있따.





================브랜치로 협업================

